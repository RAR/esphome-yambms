# YamBMS ( Yet another multi-BMS Merging Solution )

# This YAML is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 3
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/gpl.html>.

packages:
  bms_base: !include bms_base.yaml
  bms_temperature_sensor: !include bms_temperature_sensor_6.yaml

# +--------------------------------------+
# | Component settings                   |
# +--------------------------------------+

modbus_controller:
  - id: modbus_controller_bms${bms_id}
    address: ${bms_id}
    modbus_id: ${eg4_modbus_id}
    command_throttle: ${eg4_modbus_command_throttle}
    update_interval: ${eg4_modbus_update_interval}
    on_online:
      then:
        - logger.log: "EG4 BMS ${bms_id} back online !"
        - lambda: |-
            id(bms${bms_id}_online_status).publish_state(true);
    on_offline:
      then:
        - logger.log: "EG4 BMS ${bms_id} goes offline !"
        - lambda: |-
            id(bms${bms_id}_total_voltage).publish_state(0);
            id(bms${bms_id}_current).publish_state(0);
            id(bms${bms_id}_power).publish_state(0);
            id(bms${bms_id}_battery_soc).publish_state(0);
            id(bms${bms_id}_battery_soh).publish_state(0);
            id(bms${bms_id}_battery_capacity).publish_state(0);
            id(bms${bms_id}_capacity_remaining_ah).publish_state(0);
            id(bms${bms_id}_charging_cycles).publish_state(0);
            id(bms${bms_id}_max_charge_current).publish_state(0);
            id(bms${bms_id}_max_cell_voltage).publish_state(0);
            id(bms${bms_id}_max_voltage_cell).publish_state(0);
            id(bms${bms_id}_min_cell_voltage).publish_state(0);
            id(bms${bms_id}_min_voltage_cell).publish_state(0);
            id(bms${bms_id}_min_temperature).publish_state(0);
            id(bms${bms_id}_min_temperature_sensor).publish_state(0);
            id(bms${bms_id}_max_temperature).publish_state(0);
            id(bms${bms_id}_max_temperature_sensor).publish_state(0);
            id(bms${bms_id}_online_status).publish_state(false);
            id(bms${bms_id}_charging_allowed).publish_state(false);
            id(bms${bms_id}_discharging_allowed).publish_state(false);
            id(bms${bms_id}_equalizing).publish_state(false);
            id(bms${bms_id}_max_discharge_current).publish_state(0);
            id(bms${bms_id}_online_status).publish_state(false);
            id(bms${bms_id}_charging_allowed).publish_state(false);
            id(bms${bms_id}_discharging_allowed).publish_state(false);
            id(bms${bms_id}_equalizing).publish_state(false);



# +--------------------------------------+
# | Component entities                   |
# +--------------------------------------+

binary_sensor:
  # online_status
  - platform: template
    id: bms${bms_id}_online_status
    name: "${name} ${bms_name} online status"

  # Required sensors cannot be retrieved from BMS
  # equalizing
  - platform: template
    id: bms${bms_id}_equalizing
    name: "${name} ${bms_name} balancing"
    lambda: return false;
  # bms_switch_charging
  - platform: template
    id: bms${bms_id}_charging_allowed
    name: "${name} ${bms_name} charging"
    lambda: return true;
  # bms_switch_discharging
  - platform: template
    id: bms${bms_id}_discharging_allowed
    name: "${name} ${bms_name} discharging"
    lambda: return true;


## Errors
#0x0001：Voltage error
#0x0002：Temperature error
#0x0004: Current Flow Error
#0x0010：Cell unbalance
    
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} voltage error"
    register_type: holding
    address: 28
    bitmask: 0x0001

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} temperature error"
    register_type: holding
    address: 28
    bitmask: 0x0002

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} current flow error"
    register_type: holding
    address: 28
    bitmask: 0x0004

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell unbalance"
    register_type: holding
    address: 28
    bitmask: 0x0010

## Warning
#0x0001：Pack OV
#0x0002：Cell OV
#0x0004：Pack UV
#0x0008：Cell UV
#0x0010：Charge OC
#0x0020：Discharge OC
#0x0040:Abnormal Ambient Temp
#0x0080: MOS Overheating
#0x0100：Charge OT
#0x0200：Discharge OT
#0x0400：Charge UT
#0x0800：Discharge UT
#0x1000：Low capacity
#0x2000: Float Stoped

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} warning"
    register_type: holding
    address: 26

## Protection
#0x0001：Pack OV
#0x0002：Cell OV
#0x0004：Pack UV
#0x0008：Cell UV
#0x0010：Charge OC
#0x0020：Discharge OC
#0x0040: Abnormal Ambient Temp
#0x0080: MOS Overheating
#0x0100：Charge OT
#0x0200：Discharge OT
#0x0400：Charge UT
#0x0800：Discharge UT
#0x1000：Low capacity
#0x2000：Discharge SC

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} protection"
    register_type: holding
    address: 27

## Balancer Status
#0001:Cell 1Balanced
#0002: Cell 2Balanced
#0004
# ...
#0008
#8000：Cell 16 Balanced

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} balance status"
    register_type: holding
    address: 38
    bitmask: 0x0001

sensor:   
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_total_voltage
    name: "${name} ${bms_name} total voltage"
    register_type: holding
    address: 0
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    accuracy_decimals: 2
    filters: 
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_current
    name: "${name} ${bms_name} current"
    register_type: holding
    address: 1
    unit_of_measurement: "A"
    state_class: measurement
    value_type: S_WORD
    accuracy_decimals: 2
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_capacity_remaining_ah
    name: "${name} ${bms_name} remaining capacity"
    register_type: holding
    address: 21
    unit_of_measurement: "Ah"
    state_class: measurement
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_max_charge_current
    name: "${name} ${bms_name} max charging current"
    register_type: holding
    address: 22
    unit_of_measurement: "A"
    state_class: measurement
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_battery_soh
    name: "${name} ${bms_name} state of health"
    register_type: holding
    address: 23
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0
    
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_state_of_charge
    name: "${name} ${bms_name} state of charge"
    register_type: holding
    address: 24
    unit_of_measurement: "%"
    state_class: measurement
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_charging_cycles_raw
    name: "${name} ${bms_name} cycle"
    register_type: holding
    address: 29
    unit_of_measurement: ""
    state_class: measurement
    accuracy_decimals: 0
    value_type: U_DWORD

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_battery_capacity
    name: "${name} ${bms_name} total capacity"
    register_type: holding
    address: 37
    unit_of_measurement: "Ah"
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - multiply: 0.1

## Temps
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_temperature_sensor_1
    name: "${name} ${bms_name} cell temperature 1"
    register_type: holding
    address: 33
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
        return "%d", data[0];
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_temperature_sensor_2
    name: "${name} ${bms_name} cell temperature 2"
    register_type: holding
    address: 33
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
        return "%d", data[1];
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_temperature_sensor_3
    name: "${name} ${bms_name} cell temperature 3"
    register_type: holding
    address: 34
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
        return "%d", data[0];
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_temperature_sensor_4
    name: "${name} ${bms_name} cell temperature 4"
    register_type: holding
    address: 34
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
        return "%d", data[1];
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_temperature_sensor_5
    name: "${name} ${bms_name} cell temperature 5"
    register_type: holding
    address: 35
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
        return "%d", data[0];
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_temperature_sensor_6
    name: "${name} ${bms_name} cell temperature 6"
    register_type: holding
    address: 35
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    lambda: |-
        return "%d", data[1];

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} max cell temperature"
    register_type: holding
    address: 20
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    value_type: S_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} average cell temperature"
    register_type: holding
    address: 19
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    value_type: S_WORD
    accuracy_decimals: 0

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} mosfet temperature"
    register_type: holding
    address: 18
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    value_type: S_WORD
    accuracy_decimals: 0

## Cell Voltages      
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 01"
    register_type: holding
    address: 2
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) { 
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(1);
      }
      if (our_cell > cell_v_max) { 
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell); 
        id(bms${bms_id}_max_voltage_cell).publish_state(1); 
      }

      return our_cell;
      
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 02"
    register_type: holding
    address: 3
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(2);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(2);
      }

      return our_cell;
    
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 03"
    register_type: holding
    address: 4
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(3);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(3);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 04"
    register_type: holding
    address: 5
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(4);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(4);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 05"
    register_type: holding
    address: 6
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(5);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(5);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 06"
    register_type: holding
    address: 7
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(6);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(6);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 07"
    register_type: holding
    address: 8
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(7);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(7);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 08"
    register_type: holding
    address: 9
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(8);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(8);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 09"
    register_type: holding
    address: 10
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(9);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(9);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 10"
    register_type: holding
    address: 11
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(10);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(10);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 11"
    register_type: holding
    address: 12
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(11);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(11);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 12"
    register_type: holding
    address: 13
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(12);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(12);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 13"
    register_type: holding
    address: 14
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(13);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(13);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 14"
    register_type: holding
    address: 15
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(14);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(14);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 15"
    register_type: holding
    address: 16
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(15);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(15);
      }

      return our_cell;

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} cell voltage 16"
    register_type: holding
    address: 17
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 3
    lambda: |-
      float cell_v_max = id(bms${bms_id}_max_cell_voltage).state;
      float cell_v_min = id(bms${bms_id}_min_cell_voltage).state;
      float our_cell = (x * 0.001);

      if (isnan(cell_v_max)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
      if (isnan(cell_v_min)) id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);

      if (our_cell < cell_v_min) {
        id(bms${bms_id}_min_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_min_voltage_cell).publish_state(16);
      }
      if (our_cell > cell_v_max) {
        id(bms${bms_id}_max_cell_voltage).publish_state(our_cell);
        id(bms${bms_id}_max_voltage_cell).publish_state(16);
      }

      return our_cell;

   # Min. cell voltage
  - platform: template
    name: "${name} ${bms_name} min cell voltage"
    id: "bms${bms_id}_min_cell_voltage"
    unit_of_measurement: 'V'
    device_class: 'voltage'
    state_class: 'measurement'
    accuracy_decimals: 3

  # Max. cell voltage
  - platform: template
    name: "${name} ${bms_name} max cell voltage"
    id: "bms${bms_id}_max_cell_voltage"
    unit_of_measurement: 'V'
    device_class: 'voltage'
    state_class: 'measurement'
    accuracy_decimals: 3

  # Min. voltage cell
  - platform: template
    name: "${name} ${bms_name} min voltage cell"
    id: "bms${bms_id}_min_voltage_cell"
    accuracy_decimals: 0

  # Max. voltage cell
  - platform: template
    name: "${name} ${bms_name} max voltage cell"
    id: "bms${bms_id}_max_voltage_cell"
    accuracy_decimals: 0

## Either Temp till I figure out bitmasks or unavailable from the BMS
#
  - platform: template
    id: bms${bms_id}_balance_trigger_voltage
    name: "${name} ${bms_name} balance trigger voltage"
    accuracy_decimals: 3
    unit_of_measurement: "V"
    state_class: measurement
    lambda: return 3.400;
  - platform: template
    id: bms${bms_id}_cell_ovp
    name: "${name} ${bms_name} cell ovp"
    accuracy_decimals: 3
    unit_of_measurement: "V"
    state_class: measurement
    lambda: return 3.700;
  - platform: template
    id: bms${bms_id}_cell_uvp
    name: "${name} ${bms_name} cell uvp"
    accuracy_decimals: 3
    unit_of_measurement: "V"
    state_class: measurement
    lambda: return 2.500;
  - platform: template
    id: bms${bms_id}_max_discharge_current
    name: "${name} ${bms_name} max discharge current"
    accuracy_decimals: 0
    unit_of_measurement: "A"
    state_class: measurement
    lambda: return 200;

  # Power
  - platform: template
    id: bms${bms_id}_power
    name: "${name} ${bms_name} Power"
    update_interval: ${bms_update_interval}
    unit_of_measurement: W
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return id(bms${bms_id}_total_voltage).state * id(bms${bms_id}_current).state;

  # Charging Power
  - platform: template
    name: ${name} ${bms_name} Charging Power
    id: bms${bms_id}_charging_power
    update_interval: ${bms_update_interval}
    unit_of_measurement: 'W'
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      if (id(bms${bms_id}_power).state > 0)
        return id(bms${bms_id}_power).state;
      else return 0;

  # Discharging Power
  - platform: template
    name: ${name} ${bms_name} Discharging Power
    id: bms${bms_id}_discharging_power
    update_interval: ${bms_update_interval}
    unit_of_measurement: 'W'
    device_class: power
    state_class: measurement
    accuracy_decimals: 0
    lambda: |-
      if (id(bms${bms_id}_power).state <= 0)
        return (id(bms${bms_id}_power).state * -1); // Must be positive energy
      else return 0;

  # Charging cycle capacity
  - platform: template
    id: bms${bms_id}_cycle_capacity_raw
    name: "${name} ${bms_name} charging cycle capacity"
    update_interval: ${bms_update_interval}
    unit_of_measurement: Ah
    state_class: total
    icon: mdi:car-battery
    accuracy_decimals: 0
    internal: true
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return id(bms${bms_id}_charging_cycles_raw).state * id(bms${bms_id}_battery_capacity).state;

  # FAKE errors_bitmask
  # Alarm management is not supported at this time
  # Internal : only specifying an id without a name will implicitly set this to true.
  - platform: template
    id: bms${bms_id}_yambms_errors_bitmask
    update_interval: ${bms_update_interval}
    accuracy_decimals: 0
    icon: mdi:alert-circle-outline
    filters:
      - or:
        - throttle: 10s
        - delta: 1
    lambda: return 0;


## Status
#0x0000:Inactive/Stand by
#0x0001:Inactive/Charging
#0x0002:Inactive/Discharging
#0x0004:Inactive/Protect
#0x0008:Inactive/Charging Lmt
#0x8000:Active/Stand by
#0x8001:Active/Charging
#0x8002:Active/Discharging
#0x8004:Active/Protect
#0x8008:Active/Charging Lmt

#Front Byte 0x00: Heat State-Off
#Front Byte 0x80：Heat State-On
    
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    id: bms${bms_id}_status_internal    
    name: "${name} ${bms_name} status internal"
    register_type: holding
    address: 25
    lambda: |-
      ESP_LOGI("","Lambda incoming value=%f - data array size is %d",x,data.size());
      ESP_LOGI("","Sensor properties: adress = 0x%X, offset = 0x%X value type=%d",item->start_address,item->offset,item->sensor_value_type);
      int i=item->offset ;
      for (auto val : data) {
        ESP_LOGI("","data[%d]=0x%02X (%d)",i,data[i],data[i]);
        i++;
      }
      uint16_t status = uint16_t(data[item->offset+1]);
      if (status & 0x0000) return 0;
      if (status & 0x0001) return 1;
      if (status & 0x0002) return 2;
      if (status & 0x0004) return 3;  
      if (status & 0x0008) return 4;  
      if (status & 0x8000) return 5;  
      if (status & 0x8001) return 6;  
      if (status & 0x8002) return 7;  
      if (status & 0x8004) return 8;  
      if (status & 0x8008) return 9;
      return false;

## Product
text_sensor:
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} model"
    register_type: holding
    register_count: 11
    address: 105
    response_size: 24
    raw_encode: ANSI
    skip_updates: 60
    
  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} version"
    register_type: holding
    register_count: 3
    address: 117
    response_size: 6
    raw_encode: ANSI
    skip_updates: 60

  - platform: modbus_controller
    modbus_controller_id: modbus_controller_bms${bms_id}
    name: "${name} ${bms_name} firmware date"
    register_type: holding
    register_count: 8
    address: 120
    response_size: 16
    raw_encode: ANSI
    skip_updates: 60

  - platform: template
    name: "${name} ${bms_name} status"
    id: bms${bms_id}_status    
    lambda: |-
      switch ((int)id(bms${bms_id}_status_internal).state) {
        default: return std::string("Unknown");
        case 0: return std::string("Inactive/Standby");
        case 1: return std::string("Inactive/Charging");
        case 2: return std::string("Inactive/Discharging");
        case 3: return std::string("Inactive/Protect");
        case 4: return std::string("Inactive/Charging Limit");
        case 5: return std::string("Active/Standby");
        case 6: return std::string("Active/Charging");
        case 7: return std::string("Active/Discharging");
        case 8: return std::string("Active/Protect");
        case 9: return std::string("Active/Charging Limit");
      }
